---
layout: post
title: 위상정렬(topological sort)
description: topological sort
date:   2020-04-26
categories:
---
### [위상정렬]

의존성이 있는 작업들이 주어질 때, 이들을 어떤 순서로 수행해야 하는 지 계산

작업들이 주어질 때, 작업 B를 하기 전에 반드시 작업 A를 해야 한다면 작업B가 작업 A에 의존한다고 한다.

ex)

1. 멸치 육수를 붓기 위해서는 멸치 육수를 내는 작업을 먼저해야 함

2. 2등을 하기 위해선 1등이 있어야 함



각 작업을 정점으로 표현하고, 작업 간의 의존 관계를 간선으로 표현한 방향 그래프를 의존성 그래프 라고 한다.

작업v가 u에 의존한다면, 의존성 그래프는 간선(u, v)를 포함하게 된다.



의존성 그래프에서 가장 먼저 알 수 있는 특성은 그래프에 사이클이 없다는 점이다.

따라서 이 그래프는 사이클 없는 방향 그래프, 즉 **DAG**가 된다.



의존성 그래프의 정점들을 일렬로 늘어놓고, 왼쪽에서부터 하나씩 수행한다고 하자.

**이때 모든 의존성이 만족되려면, 모든 간선이 왼쪽에서 오른쪽으로 가야 한다.**

이렇게 DAG의 정점을 배열하는 문제를 **위상정렬(topological sort)**라고 한다.



위상 정렬을 구현하는 가장 직관적인 방법은 들어오는 간선이 하나도 없는 정점들을 하나씩 찾아서

정렬 결과의 뒤에 붙이고, 그래프에서 이 정점을 지우는 과정을 반복하는 것이다.

적절한 자료 구조를 사용하면 이런 알고리즘도 효율적으로 구현할 수 있지만,  깊이 우선 탐색을 이용하면

더 간단하게 이 문제를 해결할 수 있다.



그 방법은 모든 정점에 대하여 dfs()를 수행하며 dfs()가 종료할 때마다 현재 정점의 번호를 기록하는 것이다.

결국 dfsAll()을 뜻한다.

(dfs가 빨리 끝나는 순으로 정점이 기록됨)



dfsAll()이 종료한 뒤 기록된 순서를 뒤집으면 위상 정렬 결과를 얻을 수 있다.

따라서 dfs()가 늦게 종료한 정점일수록 정렬 결과의 앞에 온다.



귀류법으로 알고리즘의 정당성을 증명할 수 있다.

- 종만북 831P 참조





> 출처:프로그래밍 대회에서 배우는 알고리즘 문제해결전략 2권