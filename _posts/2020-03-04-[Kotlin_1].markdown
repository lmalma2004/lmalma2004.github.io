---
layout: post
title: Kotlin_1
description: 코틀린 공부
date:   2020-03-04
categories: Kotlin
---
# 코틀린_1



자바와 마찬가지로 코틀린도 정적 타입 지정 언어다.

정적 타입 지정이라는 말은 모든 프로그램 구성요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해준다는 뜻이다.



정적 타입 지정의 장점

1. 성능 : 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 더 빠르다.
2. 신뢰성 : 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어진다.
3. 유지 보수성 : 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
4. 도구 지원 : 정적 타입 지정을 활용하면 더 안전하게 리팩토링 할 수 있고, 도구는 더 정확한 코드 완성 기능을 제공할 수 있으며, IDE의 다른 지원 기능도 더 잘 만들 수 있다.



## 코틀린의 중요한 특성

널이 될 수 있는 타입을 지원한다는 점이다.

널이 될 수 있는 타입을 지원함에 따라 컴파일 시점에 널 포인터 예외가 발생할 수 있는지 여부를 검사할 수 있어서 좀 더 프로그램의 신뢰성을 높일 수 있다.



함수형 프로그래밍의 개념

1. 일급 시민인 함수 : 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.
2. 불변성 : 함수형 프로그래밍에서는 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다.
3. 부수 효과 없음 : 함수형 프로그래밍에서는 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다.



함수형 프로그래밍 장점

1. 간결성 : 함수형 코드는 그에 상응하는 명령형 코드에 비해 더 간결하며 우아하다. 함수를 값처럼 활용할 수 있으면 더 강력한 추상화를 할 수 있고 강력한 추상화를 사용해 코드 중복을 막을 수 있다.
2. 다중 스레드를 사용해도 안전 : 다중 스레드 프로그램에서는 적절한 동기화 없이 같은 데이터를 여러 스레드가 변경하는 경우 가장 많은 문제가 생긴다. 불변 데이터 구조를 사용하고 순수 함수를 그 데이터 구조에 적용한다면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다. 따라서 복잡한 동기화를 적용하지 않아도 된다.
3. 테스트하기 쉽다 : 부수 효과가 있는 함수는 그 함수를 실행할 때 필요한 전체 환경을 구성하는 준비 코드가 따로 필요하지만, 순수함수는 그런 준비 코드 없이 독립적으로 테스트할 수 있다.



#### 코틀린 if는 (값을 만들어내지 못하는)문장이 아니고 결과를 만드는 식이다.

ex)

```kotlin
fun max(a: Int, b: Int) : Int{

​	return if(a > b) a else b

}
```



val 변수는 블록을 싱행할 때 정확히 한 번만 초기화돼야 한다. 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

ex)

```kotlin
if(canPerformOperation()){

message = "Success"

}

else{

message = "Failed"

}
```



enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다.

다음은 프로퍼티와 메소드를 enum 안에 선언하는 방법을 보여준다.

```kotlin
enum class Color (val r: Int, val g: Int, val b: Int //상수의 프로퍼티를 정의한다
){
    RED(255, 0 ,0), ORANGE(255,165,0),
    YELLOW(255,255,0), GREEN(0,255,0), BLUE(0,0,255),
    INDIGO(75,0,130), VIOLET(238, 130, 238);

    fun rgb() = (r * 256 + g) + b
}

println(Color.BLUE.rgb())
```

enum에서도 일반적인 클래스와 마찬가지로 생성자와 프로퍼티를 선언한다. 각 enum상수를 정의할 때는 그 상수에 해당하는 프로퍼티 값을 지정해야만 한다. 이 예제에서는 코틀린에서 유일하게 세미콜론(;)이 필수인 부분을 볼 수 있다. enum 클래스 안에 메소드를 정의하는 경우 반드시 enum 상수 목록과 메소드 정의 사이에 세미콜론을 넣어야 한다.



#### when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.

ex)

```kotlin
fun mixOptimized(c1: Color, c2: Color) =
    when{
        (c1 == Color.RED && c2 == Color.YELLOW) ||
                (c1 == Color.YELLOW && c2 == Color.RED) -> Color.ORANGE
        (c1 == Color.YELLOW && c2 == Color.BLUE) ||
                (c1 == Color.BLUE && c2 == Color.YELLOW) -> Color.GREEN
        (c1 == Color.BLUE && c2 == Color.VIOLET) ||
                (c1 == Color.VIOLET && c2 == Color.BLUE) -> Color.INDIGO
        else -> throw Exception("Dirty color")
    }
println(mixOptimized(Color.BLUE, Color.YELLOW))
```



맵에 대한 이터레이션

ex)

```kotlin
val binaryReps = TreeMap<Char, String>()

for(c in 'A'..'F'){
    val binary = Integer.toBinaryString(c.toInt()) //아스키 코드를 2진표현으로 바꾼다
    binaryReps[c] = binary
}
for((letter, binary) in binaryReps){
    println("$letter = $binary")
}
```

컬렉션에 대한 이터레이션

ex)

```kotlin
val list = arrayListOf("10", "11", "1001")
for((index, element) in list.withIndex()){
    println("$index: $element")
}
```

#### 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 된다. 클래스 이름을 `수신 객체 타입(receiver type)`이라 부르며, 확장 함수가 호출되는 대상이 되는 값(객체)을 `수신 객체(receiver object)`라고 부른다.

ex)

```kotlin
//String -> 수신객체타입, this-> 수신객체

fun String.lastChar() : Char = this.get(this.length - 1)
```

클래스 안에서 정의한 메소드와 달리 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 비공개멤버나 보호된 멤버를 사용할 수 없다.

확장 함수가 정적 메소드와 같은 특징을 가지므로, 확장 함수를 하위 클래스에서 오버라이드할 수는 없다.





#### 데이터 클래스 : 모든 클래스가 정의해야 하는 메소드 자동 생성

어떤 클래스가 데이터를 저장하는 역할만을 수행한다면 toString, equals, hashCode를 반드시 오버라이드해야 한다. 다행히 이런 메소드를 정의하기는 그리 어렵지 않으며, 인텔리J 아이디어 등의 IDE는 자동으로 그런 메소드를 정의해주고, 작성된 메소드의 정확성과 일관성을 검사해준다.

코틀린은 더 편리하다. 이제는 이런 메소드를 IDE를 통해 생성할 필요도 없다. `data`라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다. `data` 변경자가 붙은 클래스를 데이터 클래스라고 부른다.