---
layout: post
title: 알고리즘의 정당성 증명
description: 귀납법과 귀류법
date:   2020-04-17
categories:
---
### 알고리즘의 정당성 증명

해결해야 할 문제가 간단할 때는 직관적으로 알고리즘을 설계할 수 있지만, 문제가 복잡해지면 이 알고리즘이 과연 문제를 제대로 해결하는지를 파악하기 조차 까다롭습니다. 단위 테스트를 이용해 여러 개의 입력에 대해 프로그램을 실행해 보고 그 답을 점검해 볼 수도 있지만, 이런 식으로는 이 알고리즘이 존재 가능한 모든 입력에 대해 정확하게 동작한다는 사실을 증명할 수 없습니다. 

**단위 테스트는 알고리즘에 문제가 잇음을 증명할 수는 있어도 문제가 없음을 증명할 수는 없기 때문입니다.**



알고리즘의 증명을 위해 사용되는 기법 중 **귀납법**과 **귀류법**에 대해 포스팅합니다.



### 수학적 귀납법

100개의 도미노가 순서대로 놓여 있는 광경을 상상해 봅시다. 그리고 우리가 다음 두 가지 사실을 안다고 가정합니다.



- 첫 번째 도미노는 직접 손으로 밀어서 쓰러뜨린다.
- 한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.



그러면 마지막 도미노 또한 당연히 쓰러진다는 것을 직관적으로 알 수 있습니다.

**수학적 귀납법(mathematical induction)**은 이와 같이 반복적인 구조를 갖는 명제들을 증명하는 데 유용하게 사용되는 기법입니다. 귀납법 증명은 크게 **3단계**로 나누어집니다.

1. **단계 나누기** : 증명하고 싶은 사실을 여러 단계로 나눕니다. 앞의 예에서는 100개의 도미노를 도미노 하나씩으로 나누었습니다.
2. **첫 단계 증명** : 그중 첫 단계에서 증명하고 싶은 내용이 성립함을 보입니다. 앞의 예에서는 첫 번째 도미노가 넘어짐을 증명하는 것이 이 과정입니다.
3. **귀납 증명** : 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보입니다. 앞의 예에서는 한 도미노가 쓰러지면 다음 도미노는 반드시 쓰러짐을 보이는 것이 이 과정입니다.



실제 귀납법을 이용한 증명의 예로 사다리 게임을 생각해 봅시다.

사다리 게임을 하다 보면 맨 위 선택지와 맨 아래 선택지가 언제나 1:1 대응이 되는 것이 신기할 때가 있습니다.

귀납법을 이용하면 이 사실을 쉽게 증명할 수 있습니다.

1. **단계 나누기** : 텅 빈 N개의 세로줄에서부터 시작해서 원하는 사다리가 될 때 까지 하나씩 가로 줄을 그어간다고 합시다. 이때 가로 줄을 하나 긋는 것을 한 단계라고 합시다.
2. **첫 단계 증명** : 텅빈 N개의 세로줄에서는 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 됩니다. 
3. **귀납 증명**: 가로줄을 그어서 두 개의 세로줄을 연결했다고 하죠. 이때 두 세로줄의 결과는 서로 뒤바뀝니다. 두 세로줄의 결과가 뒤바뀌어도 1:1대응은 변하지 않으므로 **다음 단계에서도 1:1속성이 유지됩니다.**

따라서 귀납법에 의해 가로줄만 사용하는 사다리들은 **항상 1:1로 대응**이 됨을 알 수 있습니다.



### 반복문 불변식

귀납법을 이용해 알고리즘의 정당성을 증명할 때는 **반복문 불변식(loop in variant)**이라는 개념을 유용하게 씁니다. **반복문 불변식**이란 **반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건입니다.** 반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고(그래서 불변식입니다) 성립해야 하는 것입니다.

불변식을 이용하면 반복문의 정당성을 다음과 같이 증명할 수 있습니다.

1. **반복문 진입시에 불변식이 성립함을 보인다.**
2. **반복문 내용이 불변식을 깨뜨리지 않음을 보인다. 다르게 말하면, 반복문 내용이 시작할 때 불변식이 성립했다면 내용이 끝날 때도 불변식이 항상 성립함을 보인다.**
3. **반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다.**

1번과 2번 항목을 증명했다면 수학적 귀납법을 이용해 이들은 반복문이 종료할 때까지 항상 이 불변식이 성립함을 보일 수 있습니다. 예를 들어 while문에서 실제 불변식이 성립함을 보여야 하는 위치는 다음과 같습니다.

```c++
//(*)불변식은 여기에서 성립해야 한다.
while(어떤 조건){
    //반복문 내용의 시작
    ..
    //반복문 내용의 끝
    //(**) 불변식은 여기에서도 성립해야 한다.
}
```

실제 적용 예를 위해 이진 탐색 알고리즘을 보도록 합니다.

```c++
//필수 조건: A는 오름차순으로 정렬되어 있다.
//결과: A[i-1] < x <= A[i]인 i를 반환한다.
//이때 A[-1] = 음의 무한대, A[n] = 양의 무한대라고 가정한다.
int binsearch(const vector<int>& A, int x){
    int n = A.size();
    int lo = -1;
    int hi = n;
    //반복문 불변식 1 : lo < hi
    //반복문 불변식 2 : A[lo] < x <= A[hi]
    //(*)불변식은 여기서 성립해야 한다.
    while(lo + 1 < hi){
        int mid = (lo + hi) / 2;
        if(A[mid] < x)
            lo = mid;
        else
            hi = mid;
        //(**)불변식은 여기서도 성립해야 한다.
    }
    return hi;
}
```

2개의 반복문 불변식이 while문이 완전히 종료하고 함수의 마지막 줄에 올 때까지 계속 성립했다고 가정해 봅시다. 그러면 다음 두 가지 사실을 알 수 있습니다.

- **lo + 1 = hi** **:** while문이 종료했으니 lo + 1 >= hi 인데, 불변식에 의하면 lo < hi이니 lo + 1 = hi일 수밖에 없다.
- **A[lo] < x <= A[hi] :** 애초에 불변식이 성립한다고 가정했으니 이것은 당연히 성립한다.

**우리가 원하는 결과값 i는 A[i-1] < x <= A[i]인 i**이므로 이때 우리가 원하는 답은 **hi**라는 사실을 쉽게 알 수 있습니다.

따라서 불변식이 while문 종료시에 항상 성립한다는 것을 보일 수 있다면 이 알고리즘의 정당성은 증명한 셈입니다.



반복문이 처음 시작될 때 해당 불변식이 만족함을 보이고, 반복문 내용이 한 번 지나가도 이 조건이 다시 유지됨을 보여 주면 됩니다. 엄밀하게 다음과 같이 증명할 수 있습니다.

초기 조건 : while문이 시작할 때 lo와 hi는 초기값 -1과 n으로 초기화된 상태입니다. 만약 n = 0이라면 while문을 아예 건너뛰기 때문에 불변식1은 항상 성립합니다. 우리는 A[-1] = 음의 무한대, A[n] = 양의 무한대 라고 가정하므로 불변식 2 또한 성립합니다.



유지조건 : while문 내부가 불변식을 깨뜨리지 않음을 보이면 됩니다.

- **불변식 1:** while문 내부로 들어왔다는 말은 hi와 lo의 차이가 2이상이라는 의미이므로 mid는 항상 두 값의 사이에 위치하게 됩니다. 따라서 mid를 lo에 대입하건 hi에 대입하건 항상 불변식 1은 계속 유지됩니다.
- **불변식 2:** 
  - **A[mid] < x 인 경우:** 반복문을 시작할 때 x<=A[hi]는 이미 알고 있습니다. 따라서 A[mid] < x < A[hi] 이므로, lo에 mid를 대입해도 불변식은 성립합니다.
  - **x <= A[mid]인 경우:** 반복문을 시작할 때 알고 있었던 A[lo] < x과 합쳐 보면 A[lo] < x <= A[mid]를 얻을 수 있습니다. 따라서 hi에 mid를 대입해도 불변식 2는 성립합니다.



**이런 과정을 거쳐 while문이 종료될 때 우리가 원하는 값이 A[hi]에 저장되어 있음을 알 수 있습니다.**



### 귀류법

우리가 원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법



**예시 : 책장 쌓기**

상자 형태로 된 책장를 여러 개 쌓아올리려고 합니다. 무거운 것부터 가벼운 것, 책만 꽂아도 부서질 것 같은 비실비실한 것부터 코끼리가 올라가도 될 것 같은 튼튼한 것까지 다양한 책장들이 있습니다. 각 책장마다 버틸 수 있는 최대 무게 Mi와 자신의 무게 Wi가 주어진다고 합시다. 이때 책장을 가장 높이 쌓는다면 몇 개나 쌓을 수 있을까요?



**이 문제에 대한 증명은 종만북1권 136p에 나와있다. 궁금하면 찾아보기**



> 출처 : 프로그래밍 대회에서 배우는 알고리즘 문제해결전략 1권